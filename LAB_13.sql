USE DBMS

SELECT * FROM PERSON_DATA
SELECT * FROM DBO.UNIQUE_FNAME()

-- PART :: A

-- 1.
CREATE FUNCTION HELLO_WORLD()
RETURNS VARCHAR(100)
AS
BEGIN
	RETURN 'HELLO WORLD'
END
-- 2.
CREATE FUNCTION SUM_TWO_NO(@N1 INT , @N2 INT)
RETURNS INT
AS
BEGIN
	RETURN @N1 + @N2
END
-- 3.
CREATE FUNCTION ODD_EVEN(@N1 INT)
RETURNS VARCHAR(50)
AS
BEGIN
	DECLARE @RESULT VARCHAR(50)
	IF(@N1 % 2 = 0)
		SET @RESULT = 'NUMBER IS EVEN'
	ELSE
		SET @RESULT = 'NUMBER IS ODD'
	RETURN @RESULT
END
-- 4.
CREATE FUNCTION PERSON_START_B()
RETURNS TABLE
AS 
RETURN (SELECT * FROM PERSON_DATA WHERE FIRSTNAME LIKE 'B%')
--5.
CREATE FUNCTION UNIQUE_FNAME()
RETURNS TABLE
AS 
RETURN (SELECT DISTINCT FIRSTNAME FROM PERSON_DATA)
-- 6.
CREATE FUNCTION ONE_TO_N(@N INT)
RETURNS VARCHAR(100)
AS
BEGIN
	DECLARE @RESULT VARCHAR(100) = ''
	DECLARE @I INT = 1
	WHILE @I <= @N
	BEGIN
		SET @RESULT = @RESULT +  CAST(@I AS VARCHAR(100)) + ' '
		SET @I = @I + 1
	END
	RETURN @RESULT
END
-- 7.
CREATE FUNCTION FACTORIAL_OF_NO(@N INT)
RETURNS INT
AS
BEGIN
	DECLARE @I INT = 1 , @ANS INT = 1
	WHILE @I <= @N
	BEGIN
		SET @ANS = @ANS * @I
		SET @I = @I + 1
	END
	RETURN @ANS
END



-- PART :: B

-- 1.
CREATE FUNCTION COMPARE_TWO_INT(@N1 INT , @N2 INT)
RETURNS VARCHAR(100)
AS
BEGIN
	DECLARE @RESULT VARCHAR(100)
	SET @RESULT = CASE
		WHEN @N1 > @N2 THEN CAST(@N1 AS VARCHAR) + ' IS MAXIMUM'
		WHEN @N1 < @N2 THEN CAST(@N2 AS VARCHAR) + ' IS MAXIMUM'
		ELSE 'BOTH ARE SAME'
	END
	RETURN @RESULT
END
-- 2.
CREATE FUNCTION SUM_OF_EVEN()
RETURNS INT
AS
BEGIN
	DECLARE @SUM INT = 0 , @I INT = 1
	WHILE(@I <= 20)
	BEGIN
		IF @I % 2 = 0
			SET @SUM = @SUM + @I
		SET @I = @I + 1
	END
	RETURN @SUM
END
-- 3.
CREATE FUNCTION PELINDROME_STRING(@S VARCHAR(100))
RETURNS VARCHAR(100)
AS
BEGIN
	DECLARE @RESULT VARCHAR(100) , @REVERSE VARCHAR(100)
	SET @REVERSE = REVERSE(@S)
	IF @S = @REVERSE
		SET @RESULT = 'STRING IS PELINDROME'
	ELSE
		SET @RESULT = 'STRING IS NOT PELINDROME'
	RETURN @RESULT
END



-- PART :: C

-- 1.
ALTER FUNCTION PRIME_NO(@N INT)
RETURNS VARCHAR(100)
AS
BEGIN
	DECLARE @I INT = 2 , @RESULT VARCHAR(100) , @FLAG INT = 0
	IF(@N = 1)
	BEGIN
		RETURN 'ENTER A NUMBER GREATER THEN 1'
	END
	WHILE @I <= @N
	BEGIN
		IF @N % @I = 0
		BEGIN
			SET @FLAG = @FLAG+1
			IF(@FLAG>1)
			BEGIN
				BREAK
			END
		END
		SET @I = @I + 1
	END
	IF @FLAG = 1
		SET @RESULT = 'NUMBER IS PRIME'
	ELSE
		SET @RESULT = 'NUMBER IS NOT PRIME'
	RETURN @RESULT
END

SELECT DBO.PRIME_NO(1)

-- 2.
CREATE FUNCTION DAY_DIFF(@ST_DATE DATE,@END_DATE DATE)
RETURNS INT
AS
BEGIN
	DECLARE @DAYS INT=0
	SET @DAYS = DATEDIFF(DAY,@ST_DATE,@END_DATE)
	RETURN @DAYS
END
SELECT DBO.DAY_DIFF('1990-01-01','1992-01-01')

-- 3.
CREATE FUNCTION TOT_DAY(@YEAR INT,@MONTH INT)
RETURNS INT
AS
BEGIN
	DECLARE @TOTAL_DAYS INT=0
	RETURN DAY(EOMONTH(CAST(@YEAR AS VARCHAR)+'-'+CAST(@MONTH AS VARCHAR)+'-01'))
END
SELECT DBO.TOT_DAY(2025,5)

-- 4.
CREATE FUNCTION PER_DETAIL(@DEPT_ID INT)
RETURNS TABLE
AS
RETURN(SELECT * FROM PERSON_DATA WHERE DEPARTMENTID=@DEPT_ID)

SELECT * FROM DBO.PER_DETAIL(2)

-- 5.
CREATE FUNCTION RET_TABLE()
RETURNS TABLE
AS
RETURN(SELECT * FROM PERSON_DATA WHERE JOININGDATE>'1991-01-01')

SELECT * FROM DBO.RET_TABLE()